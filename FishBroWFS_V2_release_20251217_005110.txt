================================================================================
FishBroWFS_V2 Release Package
Generated: 2025-12-17 00:51:10
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
FishBroWFS_V2/
    ├── GM_Huang/
    │   ├── clean_repo_caches.py
    │   └── release_tool.py
    ├── scripts/
    │   └── perf_grid.py
    ├── src/
    │   └── FishBroWFS_V2/
    │       ├── data/
    │       │   ├── __init__.py
    │       │   └── layout.py
    │       ├── engine/
    │       │   ├── __init__.py
    │       │   ├── constitution.py
    │       │   ├── engine_jit.py
    │       │   ├── matcher_core.py
    │       │   └── types.py
    │       ├── indicators/
    │       │   ├── __init__.py
    │       │   └── numba_indicators.py
    │       ├── pipeline/
    │       │   ├── __init__.py
    │       │   ├── param_sort.py
    │       │   └── runner_grid.py
    │       ├── strategy/
    │       │   ├── __init__.py
    │       │   ├── kernel.py
    │       │   └── runner_single.py
    │       ├── __init__.py
    │       └── version.py
    └── tests/
        ├── test_baseline_lock.py
        ├── test_data_layout.py
        ├── test_engine_constitution.py
        ├── test_engine_gaps_and_priority.py
        ├── test_golden_kernel_verification.py
        ├── test_grid_runner_smoke.py
        └── test_indicators_consistency.py

================================================================================
PYTHON FILES AND CODE
================================================================================


================================================================================
FILE: GM_Huang/clean_repo_caches.py
================================================================================

#!/usr/bin/env python3
from __future__ import annotations

import os
from pathlib import Path


def _is_under(path: Path, parent: Path) -> bool:
    try:
        path.resolve().relative_to(parent.resolve())
        return True
    except Exception:
        return False


def clean_repo_caches(repo_root: Path, dry_run: bool = False) -> tuple[int, int]:
    """
    Remove Python bytecode caches inside repo_root:
      - __pycache__ directories
      - *.pyc, *.pyo
    Does NOT touch anything outside repo_root.
    """
    removed_dirs = 0
    removed_files = 0

    for p in repo_root.rglob("__pycache__"):
        if not p.is_dir():
            continue
        if not _is_under(p, repo_root):
            continue
        if dry_run:
            print(f"[DRY] rmdir: {p}")
        else:
            for child in p.rglob("*"):
                try:
                    if child.is_file() or child.is_symlink():
                        child.unlink(missing_ok=True)
                        removed_files += 1
                except Exception:
                    pass
            try:
                p.rmdir()
                removed_dirs += 1
            except Exception:
                pass

    for ext in ("*.pyc", "*.pyo"):
        for p in repo_root.rglob(ext):
            if not p.is_file() and not p.is_symlink():
                continue
            if not _is_under(p, repo_root):
                continue
            if dry_run:
                print(f"[DRY] rm: {p}")
            else:
                try:
                    p.unlink(missing_ok=True)
                    removed_files += 1
                except Exception:
                    pass

    return removed_dirs, removed_files


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    dry_run = os.environ.get("FISHBRO_DRY_RUN", "").strip() == "1"
    removed_dirs, removed_files = clean_repo_caches(repo_root, dry_run=dry_run)

    if dry_run:
        print("[DRY] Done.")
        return

    print(f"Cleaned {removed_dirs} __pycache__ directories and {removed_files} bytecode files.")


if __name__ == "__main__":
    main()


================================================================================
FILE: GM_Huang/release_tool.py
================================================================================

#!/usr/bin/env python3
"""
Release tool for FishBroWFS_V2.

Generates release packages (txt or zip) excluding sensitive information like .git
"""

from __future__ import annotations

import os
import zipfile
from datetime import datetime
from pathlib import Path


def should_exclude(path: Path, repo_root: Path) -> bool:
    """
    Check if a path should be excluded from release.
    
    Excludes:
    - .git directory and all its contents
    - __pycache__ directories
    - .pyc, .pyo files
    - Common build/test artifacts
    """
    path_str = str(path)
    path_parts = path.parts
    
    # Exclude .git directory
    if '.git' in path_parts:
        return True
    
    # Exclude cache directories
    if '__pycache__' in path_parts:
        return True
    
    # Exclude bytecode files
    if path.suffix in ('.pyc', '.pyo'):
        return True
    
    # Exclude common build/test artifacts
    exclude_names = {
        '.pytest_cache', '.mypy_cache', '.ruff_cache',
        '.coverage', 'htmlcov', '.tox', 'dist', 'build',
        '*.egg-info', '.eggs'
    }
    
    for name in exclude_names:
        if name in path_parts or path.name.startswith(name.replace('*', '')):
            return True
    
    # Exclude GM_Huang itself from the release (optional, but makes sense)
    # Actually, let's include it since it's part of the project structure
    
    return False


def get_python_files(repo_root: Path) -> list[Path]:
    """Get all Python files in the repository, excluding sensitive paths."""
    python_files = []
    
    for py_file in repo_root.rglob('*.py'):
        if not should_exclude(py_file, repo_root):
            python_files.append(py_file)
    
    return sorted(python_files)


def get_directory_structure(repo_root: Path) -> str:
    """Generate a text representation of directory structure."""
    lines = []
    
    def walk_tree(directory: Path, prefix: str = '', is_last: bool = True):
        """Recursively walk directory tree and build structure."""
        if should_exclude(directory, repo_root):
            return
        
        # Skip if it's the repo root itself
        if directory == repo_root:
            lines.append(f"{directory.name}/")
        else:
            connector = "└── " if is_last else "├── "
            lines.append(f"{prefix}{connector}{directory.name}/")
        
        # Get subdirectories and files
        try:
            items = sorted([p for p in directory.iterdir() 
                          if not should_exclude(p, repo_root)])
            dirs = [p for p in items if p.is_dir()]
            files = [p for p in items if p.is_file() and p.suffix == '.py']
            
            # Process directories
            for i, item in enumerate(dirs):
                is_last_item = (i == len(dirs) - 1) and len(files) == 0
                extension = "    " if is_last else "│   "
                walk_tree(item, prefix + extension, is_last_item)
            
            # Process Python files
            for i, file in enumerate(files):
                is_last_item = i == len(files) - 1
                connector = "└── " if is_last_item else "├── "
                lines.append(f"{prefix}{'    ' if is_last else '│   '}{connector}{file.name}")
        except PermissionError:
            pass
    
    walk_tree(repo_root)
    return "\n".join(lines)


def generate_release_txt(repo_root: Path, output_path: Path) -> None:
    """Generate a text file with directory structure and Python code."""
    print(f"Generating release TXT: {output_path}")
    
    with open(output_path, 'w', encoding='utf-8') as f:
        # Header
        f.write("=" * 80 + "\n")
        f.write(f"FishBroWFS_V2 Release Package\n")
        f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write("=" * 80 + "\n\n")
        
        # Directory structure
        f.write("DIRECTORY STRUCTURE\n")
        f.write("-" * 80 + "\n")
        f.write(get_directory_structure(repo_root))
        f.write("\n\n")
        
        # Python files and their content
        f.write("=" * 80 + "\n")
        f.write("PYTHON FILES AND CODE\n")
        f.write("=" * 80 + "\n\n")
        
        python_files = get_python_files(repo_root)
        
        for py_file in python_files:
            relative_path = py_file.relative_to(repo_root)
            f.write(f"\n{'=' * 80}\n")
            f.write(f"FILE: {relative_path}\n")
            f.write(f"{'=' * 80}\n\n")
            
            try:
                content = py_file.read_text(encoding='utf-8')
                f.write(content)
                if not content.endswith('\n'):
                    f.write('\n')
            except Exception as e:
                f.write(f"[ERROR: Could not read file: {e}]\n")
            
            f.write("\n")
    
    print(f"✓ Release TXT generated: {output_path}")


def generate_release_zip(repo_root: Path, output_path: Path) -> None:
    """Generate a zip file of the project, excluding sensitive information."""
    print(f"Generating release ZIP: {output_path}")
    
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        python_files = get_python_files(repo_root)
        
        # Also include non-Python files that are important
        important_extensions = {'.toml', '.txt', '.md', '.yml', '.yaml'}
        important_files = []
        
        for ext in important_extensions:
            for file in repo_root.rglob(f'*{ext}'):
                if not should_exclude(file, repo_root):
                    important_files.append(file)
        
        all_files = sorted(set(python_files + important_files))
        
        for file_path in all_files:
            relative_path = file_path.relative_to(repo_root)
            zipf.write(file_path, relative_path)
            print(f"  Added: {relative_path}")
    
    print(f"✓ Release ZIP generated: {output_path}")
    print(f"  Total files: {len(all_files)}")


def main() -> None:
    """Main entry point."""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python release_tool.py [txt|zip]")
        sys.exit(1)
    
    mode = sys.argv[1].lower()
    
    # Get repo root (parent of GM_Huang)
    script_dir = Path(__file__).resolve().parent
    repo_root = script_dir.parent
    
    # Generate output filename with timestamp
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    project_name = repo_root.name
    
    if mode == 'txt':
        output_path = repo_root / f"{project_name}_release_{timestamp}.txt"
        generate_release_txt(repo_root, output_path)
    elif mode == 'zip':
        output_path = repo_root / f"{project_name}_release_{timestamp}.zip"
        generate_release_zip(repo_root, output_path)
    else:
        print(f"Unknown mode: {mode}. Use 'txt' or 'zip'")
        sys.exit(1)


if __name__ == "__main__":
    main()


================================================================================
FILE: scripts/perf_grid.py
================================================================================

#!/usr/bin/env python3
"""
FishBro WFS Perf Harness (Red Team Spec v1.0)
狀態: ✅ File-based IPC / JIT-First / Observable
用途: 量測 JIT Grid Runner 的穩態吞吐量 (Steady-state Throughput)

修正紀錄:
- v1.1: 修復 numpy generator abs 錯誤
- v1.2: Hotfix: 解決 subprocess Import Error，強制注入 PYTHONPATH 並增強 debug info
"""
import os
import sys
import time
import gc
import json
import argparse
import subprocess
import tempfile
import statistics
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional

import numpy as np

# ==========================================
# 1. 配置與常數 (Tiers)
# ==========================================

@dataclass
class PerfConfig:
    name: str
    n_bars: int
    n_params: int
    hot_runs: int
    timeout: int
    disable_jit: bool
    sort_params: bool

# Warmup Tier: Ensure cold can complete within timeout to get hot (steady-state) numbers
TIER_JIT_BARS = int(os.environ.get("FISHBRO_PERF_BARS", "200000"))
TIER_JIT_PARAMS = int(os.environ.get("FISHBRO_PERF_PARAMS", "10000"))
TIER_JIT_HOT_RUNS = int(os.environ.get("FISHBRO_PERF_HOTRUNS", "5"))
TIER_JIT_TIMEOUT = int(os.environ.get("FISHBRO_PERF_TIMEOUT_S", "600"))

# Stress Tier: Optional, for extreme throughput testing (requires larger timeout or skip-cold)
TIER_STRESS_BARS = int(os.environ.get("FISHBRO_PERF_STRESS_BARS", "200000"))
TIER_STRESS_PARAMS = int(os.environ.get("FISHBRO_PERF_STRESS_PARAMS", "10000"))

TIER_TOY_BARS = 2_000
TIER_TOY_PARAMS = 10
TIER_TOY_HOT_RUNS = 1
TIER_TOY_TIMEOUT = 60

# Warmup compile tier (for skip-cold mode)
TIER_WARMUP_COMPILE_BARS = 2_000
TIER_WARMUP_COMPILE_PARAMS = 200

PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(PROJECT_ROOT / "src"))

# ==========================================
# 2. 資料生成 (Deterministic)
# ==========================================

def generate_synthetic_data(n_bars: int, seed: int = 42) -> Dict[str, np.ndarray]:
    rng = np.random.default_rng(seed)
    close = 10000 + np.cumsum(rng.standard_normal(n_bars)) * 10
    high = close + np.abs(rng.standard_normal(n_bars)) * 5
    low = close - np.abs(rng.standard_normal(n_bars)) * 5
    open_ = (high + low) / 2 + rng.standard_normal(n_bars)
    
    high = np.maximum(high, np.maximum(open_, close))
    low = np.minimum(low, np.minimum(open_, close))
    
    data = {
        "open": open_.astype(np.float64),
        "high": high.astype(np.float64),
        "low": low.astype(np.float64),
        "close": close.astype(np.float64),
    }
    
    for k, v in data.items():
        if not v.flags['C_CONTIGUOUS']:
            data[k] = np.ascontiguousarray(v)
    return data

def generate_params(n_params: int, seed: int = 999) -> np.ndarray:
    rng = np.random.default_rng(seed)
    w1 = rng.integers(10, 100, size=n_params)
    w2 = rng.integers(5, 50, size=n_params)
    # runner_grid contract: params_matrix must be (n, >=3)
    # Provide a minimal 3-column schema for perf harness.
    w3 = rng.integers(2, 30, size=n_params)
    params = np.column_stack((w1, w2, w3)).astype(np.float64)
    if not params.flags['C_CONTIGUOUS']:
        params = np.ascontiguousarray(params)
    return params

# ==========================================
# 3. Worker 邏輯 (Child Process)
# ==========================================

def worker_log(msg: str):
    print(f"[worker] {msg}", flush=True)

def run_worker(npz_path: str, hot_runs: int, skip_cold: bool = False, warmup_bars: int = 0, warmup_params: int = 0):
    try:
        worker_log(f"Starting. Loading input: {npz_path}")
        
        with np.load(npz_path, allow_pickle=False) as data:
            opens = data['open']
            highs = data['high']
            lows = data['low']
            closes = data['close']
            params = data['params']
            
        worker_log(f"Data loaded. Bars: {len(opens)}, Params: {len(params)}")
        
        try:
            # Phase 3B Grid Runner (correct target)
            # src/FishBroWFS_V2/pipeline/runner_grid.py
            from FishBroWFS_V2.pipeline.runner_grid import run_grid  # type: ignore
            worker_log("Grid runner imported successfully (FishBroWFS_V2.pipeline.runner_grid).")
        except ImportError as e:
            worker_log(f"FATAL: Import grid runner failed: {e!r}")
            
            # --- DEBUG INFO ---
            worker_log(f"Current sys.path: {sys.path}")
            src_path = Path(__file__).resolve().parent.parent / "src"
            if src_path.exists():
                worker_log(f"Listing {src_path}:")
                try:
                    for p in src_path.iterdir():
                        worker_log(f" - {p.name}")
                        if p.is_dir() and (p / "__init__.py").exists():
                             worker_log(f"   (package content): {[sub.name for sub in p.iterdir()]}")
                except Exception as ex:
                    worker_log(f"   Error listing dir: {ex}")
            else:
                worker_log(f"Src path not found at: {src_path}")
            # ------------------
            sys.exit(1)
        
        # Warmup run (perf-only): compile/JIT on a tiny slice so the real run measures steady-state.
        warmup_bars = min(2000, len(opens))
        warmup_params = min(200, len(params))
        if warmup_bars >= 10 and warmup_params >= 10:
            worker_log(f"Starting WARMUP run (bars={warmup_bars}, params={warmup_params})...")
            _ = run_grid(
                open_=opens[:warmup_bars],
                high=highs[:warmup_bars],
                low=lows[:warmup_bars],
                close=closes[:warmup_bars],
                params_matrix=params[:warmup_params],
                commission=0.0,
                slip=0.0,
                sort_params=False,
            )
            worker_log("WARMUP finished.")
        
        cold_time = 0.0
        if skip_cold:
            # Skip-cold mode: warmup already done, skip full cold run
            worker_log("Skip-cold mode: skipping full cold run (warmup already completed)")
        else:
            # Full cold run
            worker_log("Starting COLD run...")
            t0 = time.perf_counter()
            _ = run_grid(
                open_=opens,
                high=highs,
                low=lows,
                close=closes,
                params_matrix=params,
                commission=0.0,
                slip=0.0,
                sort_params=False,
            )
            cold_time = time.perf_counter() - t0
            worker_log(f"COLD run finished: {cold_time:.4f}s")
        
        worker_log(f"Starting {hot_runs} HOT runs (GC disabled)...")
        hot_times = []
        gc.disable()
        try:
            for i in range(hot_runs):
                t_start = time.perf_counter()
                _ = run_grid(
                    open_=opens,
                    high=highs,
                    low=lows,
                    close=closes,
                    params_matrix=params,
                    commission=0.0,
                    slip=0.0,
                    sort_params=False,
                )
                t_end = time.perf_counter()
                hot_times.append(t_end - t_start)
        finally:
            gc.enable()
        
        avg_hot = statistics.mean(hot_times) if hot_times else 0.0
        min_hot = min(hot_times) if hot_times else 0.0
        
        result = {
            "cold_time": cold_time,
            "hot_times": hot_times,
            "avg_hot_time": avg_hot,
            "min_hot_time": min_hot,
            "n_bars": len(opens),
            "n_params": len(params),
            "throughput": (len(opens) * len(params)) / min_hot if min_hot > 0 else 0
        }
        
        print(f"__RESULT_JSON_START__")
        print(json.dumps(result))
        print(f"__RESULT_JSON_END__")
        
    except Exception as e:
        worker_log(f"CRASH: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

# ==========================================
# 4. Controller 邏輯 (Host Process)
# ==========================================

def run_lane(lane_id: int, cfg: PerfConfig, tmp_dir: str, ohlc_data: Dict[str, np.ndarray]) -> Dict[str, Any]:
    print(f"\n>>> Running Lane {lane_id}: {cfg.name}")
    print(f"    Config: Bars={cfg.n_bars}, Params={cfg.n_params}, JIT={not cfg.disable_jit}, Sort={cfg.sort_params}")
    
    params = generate_params(cfg.n_params)
    if cfg.sort_params:
        idx = np.argsort(params[:, 0])
        params = params[idx]
        print("    Params sorted by primary key.")
    else:
        np.random.shuffle(params)
        print("    Params shuffled (random access simulation).")
        
    npz_path = os.path.join(tmp_dir, f"input_lane_{lane_id}.npz")
    np.savez_compressed(
        npz_path, 
        open=ohlc_data["open"][:cfg.n_bars],
        high=ohlc_data["high"][:cfg.n_bars],
        low=ohlc_data["low"][:cfg.n_bars],
        close=ohlc_data["close"][:cfg.n_bars],
        params=params
    )
    
    env = os.environ.copy()
    
    # 關鍵修正: 強制注入 PYTHONPATH 確保子進程看得到 src
    src_path = str(PROJECT_ROOT / "src")
    if "PYTHONPATH" in env:
        env["PYTHONPATH"] = f"{src_path}:{env['PYTHONPATH']}"
    else:
        env["PYTHONPATH"] = src_path
        
    if cfg.disable_jit:
        env["NUMBA_DISABLE_JIT"] = "1"
    else:
        env.pop("NUMBA_DISABLE_JIT", None)
        
    # Build worker command
    cmd = [sys.executable, __file__, "--worker", "--input", npz_path, "--hot-runs", str(cfg.hot_runs)]
    
    # Add skip-cold and warmup params if needed
    skip_cold = os.environ.get("FISHBRO_PERF_SKIP_COLD", "").lower() == "true"
    if skip_cold:
        cmd.extend(["--skip-cold"])
        warmup_bars = int(os.environ.get("FISHBRO_PERF_WARMUP_BARS", str(TIER_WARMUP_COMPILE_BARS)))
        warmup_params = int(os.environ.get("FISHBRO_PERF_WARMUP_PARAMS", str(TIER_WARMUP_COMPILE_PARAMS)))
        cmd.extend(["--warmup-bars", str(warmup_bars), "--warmup-params", str(warmup_params)])
    
    try:
        proc = subprocess.run(
            cmd,
            env=env,
            capture_output=True,
            text=True,
            timeout=cfg.timeout,
            check=True
        )
        
        stdout = proc.stdout
        result_json = None
        lines = stdout.splitlines()
        capture = False
        json_str = ""
        
        for line in lines:
            if line.strip() == "__RESULT_JSON_END__":
                capture = False
            if capture:
                json_str += line
            if line.strip() == "__RESULT_JSON_START__":
                capture = True
                
        if json_str:
            result_json = json.loads(json_str)
            return result_json
        else:
            print("❌ Error: Worker finished but no JSON result found.")
            print("--- Worker Stdout ---")
            print(stdout)
            print("--- Worker Stderr ---")
            print(proc.stderr)
            return {}
            
    except subprocess.TimeoutExpired as e:
        print(f"❌ Error: Lane {lane_id} Timeout ({cfg.timeout}s).")
        if e.stdout: print(e.stdout)
        if e.stderr: print(e.stderr)
        return {}
    except subprocess.CalledProcessError as e:
        print(f"❌ Error: Lane {lane_id} Crashed (Exit {e.returncode}).")
        print("--- Worker Stdout ---")
        print(e.stdout)
        print("--- Worker Stderr ---")
        print(e.stderr)
        return {}
    except Exception as e:
        print(f"❌ Error: System error {e}")
        return {}

def print_report(results: List[Dict[str, Any]]):
    print("\n\n=== FishBro WFS Perf Harness Report ===")
    print("| Lane | Mode | Sort | Bars | Params | Cold(s) | Hot(s) | Tput (Params/s) | Speedup |")
    print("|---|---|---|---|---|---|---|---|---|")
    
    jit_no_sort_tput = 0
    for r in results:
        if not r: continue
        lane_id = r['lane_id']
        name = r['name']
        bars = r['res'].get('n_bars', 0)
        params = r['res'].get('n_params', 0)
        cold = r['res'].get('cold_time', 0)
        hot = r['res'].get('min_hot_time', 0)
        tput = r['res'].get('throughput', 0)
        
        if lane_id == 3:
            jit_no_sort_tput = tput
            speedup = "1.0x (Base)"
        elif jit_no_sort_tput > 0 and tput > 0:
            ratio = tput / jit_no_sort_tput
            speedup = f"{ratio:.2f}x"
        else:
            speedup = "-"
            
        mode = "Py" if "Py" in name else "JIT"
        sort = "Yes" if "Sort" in name else "No"
        print(f"| {lane_id} | {mode} | {sort} | {bars} | {params} | {cold:.4f} | {hot:.4f} | {int(tput):,} | {speedup} |")
    print("\nNote: Tput = (Bars * Params) / Min Hot Run Time")

def main():
    parser = argparse.ArgumentParser(description="FishBro WFS Perf Harness")
    parser.add_argument("--worker", action="store_true", help="Run as worker")
    parser.add_argument("--input", type=str, help="Path to input NPZ")
    parser.add_argument("--hot-runs", type=int, default=5, help="Hot runs")
    parser.add_argument("--skip-cold", action="store_true", help="Skip full cold run, use warmup compile instead")
    parser.add_argument("--warmup-bars", type=int, default=0, help="Warmup compile bars (for skip-cold)")
    parser.add_argument("--warmup-params", type=int, default=0, help="Warmup compile params (for skip-cold)")
    parser.add_argument("--include-python-baseline", action="store_true", help="Include Toy Tier")
    parser.add_argument("--stress-tier", action="store_true", help="Use stress tier (200k×10k) instead of warmup tier")
    args = parser.parse_args()
    
    if args.worker:
        if not args.input: sys.exit(1)
        run_worker(args.input, args.hot_runs, args.skip_cold, args.warmup_bars, args.warmup_params)
        return

    print("Initializing Perf Harness...")
    lanes_cfg: List[PerfConfig] = []
    
    # Select tier based on stress-tier flag
    if args.stress_tier:
        jit_bars = TIER_STRESS_BARS
        jit_params = TIER_STRESS_PARAMS
        print(f"Using STRESS tier: {jit_bars:,} bars × {jit_params:,} params")
    else:
        jit_bars = TIER_JIT_BARS
        jit_params = TIER_JIT_PARAMS
        print(f"Using WARMUP tier: {jit_bars:,} bars × {jit_params:,} params")
    
    if args.include_python_baseline:
        lanes_cfg.append(PerfConfig("Lane 1 (Py, No Sort)", TIER_TOY_BARS, TIER_TOY_PARAMS, TIER_TOY_HOT_RUNS, TIER_TOY_TIMEOUT, True, False))
        lanes_cfg.append(PerfConfig("Lane 2 (Py, Sort)", TIER_TOY_BARS, TIER_TOY_PARAMS, TIER_TOY_HOT_RUNS, TIER_TOY_TIMEOUT, True, True))
        
    lanes_cfg.append(PerfConfig("Lane 3 (JIT, No Sort)", jit_bars, jit_params, TIER_JIT_HOT_RUNS, TIER_JIT_TIMEOUT, False, False))
    lanes_cfg.append(PerfConfig("Lane 4 (JIT, Sort)", jit_bars, jit_params, TIER_JIT_HOT_RUNS, TIER_JIT_TIMEOUT, False, True))
    
    max_bars = max(c.n_bars for c in lanes_cfg)
    print(f"Generating synthetic data (Max Bars: {max_bars})...")
    ohlc_data = generate_synthetic_data(max_bars)
    
    results = []
    with tempfile.TemporaryDirectory() as tmp_dir:
        print(f"Created temp dir for IPC: {tmp_dir}")
        for i, cfg in enumerate(lanes_cfg):
            lane_id = i + 1
            if not args.include_python_baseline: lane_id += 2 
            res = run_lane(lane_id, cfg, tmp_dir, ohlc_data)
            if res: results.append({"lane_id": lane_id, "name": cfg.name, "res": res})
            else: results.append({})
            
    print_report(results)

if __name__ == "__main__":
    main()


================================================================================
FILE: src/FishBroWFS_V2/__init__.py
================================================================================




================================================================================
FILE: src/FishBroWFS_V2/data/__init__.py
================================================================================




================================================================================
FILE: src/FishBroWFS_V2/data/layout.py
================================================================================

import numpy as np
from FishBroWFS_V2.engine.types import BarArrays


def ensure_float64_contiguous(x: np.ndarray) -> np.ndarray:
    arr = np.asarray(x, dtype=np.float64)
    if not arr.flags["C_CONTIGUOUS"]:
        arr = np.ascontiguousarray(arr)
    return arr


def normalize_bars(
    open_: np.ndarray,
    high: np.ndarray,
    low: np.ndarray,
    close: np.ndarray,
) -> BarArrays:
    arrays = [open_, high, low, close]
    for a in arrays:
        if np.isnan(a).any():
            raise ValueError("NaN detected in input data")

    o = ensure_float64_contiguous(open_)
    h = ensure_float64_contiguous(high)
    l = ensure_float64_contiguous(low)
    c = ensure_float64_contiguous(close)

    return BarArrays(open=o, high=h, low=l, close=c)



================================================================================
FILE: src/FishBroWFS_V2/engine/__init__.py
================================================================================




================================================================================
FILE: src/FishBroWFS_V2/engine/constitution.py
================================================================================

"""
Engine Constitution v1.1 (FROZEN)

Activation:
- Orders are created at Bar[T] close and become active at Bar[T+1].

STOP fills (Open==price is treated as GAP branch):
Buy Stop @ S:
- if Open >= S: fill = Open
- elif High >= S: fill = S
Sell Stop @ S:
- if Open <= S: fill = Open
- elif Low <= S: fill = S

LIMIT fills (Open==price is treated as GAP branch):
Buy Limit @ L:
- if Open <= L: fill = Open
- elif Low <= L: fill = L
Sell Limit @ L:
- if Open >= L: fill = Open
- elif High >= L: fill = L

Priority:
- STOP wins over LIMIT (risk-first pessimism).

Same-bar In/Out:
- If entry and exit are both triggerable in the same bar, execute Entry then Exit.

Same-kind tie rule:
- If multiple orders of the same role are triggerable in the same bar, execute EXIT-first.
- Within the same role+kind, use deterministic order: smaller order_id first.
"""

NEXT_BAR_ACTIVE = True
PRIORITY_STOP_OVER_LIMIT = True
SAME_BAR_ENTRY_THEN_EXIT = True
SAME_KIND_TIE_EXIT_FIRST = True



================================================================================
FILE: src/FishBroWFS_V2/engine/engine_jit.py
================================================================================

from __future__ import annotations

from dataclasses import asdict
from typing import Iterable, List

import numpy as np

try:
    import numba as nb
except Exception:  # pragma: no cover
    nb = None  # type: ignore

from FishBroWFS_V2.engine.types import (
    BarArrays,
    Fill,
    OrderIntent,
    OrderKind,
    OrderRole,
    Side,
)
from FishBroWFS_V2.engine.matcher_core import simulate as simulate_py


def _to_int(x) -> int:
    # Enum values are int/str; we convert deterministically.
    if isinstance(x, Side):
        return int(x.value)
    if isinstance(x, OrderRole):
        # EXIT first tie-break relies on role; map explicitly.
        return 0 if x == OrderRole.EXIT else 1
    if isinstance(x, OrderKind):
        return 0 if x == OrderKind.STOP else 1
    return int(x)


def _to_kind_int(k: OrderKind) -> int:
    return 0 if k == OrderKind.STOP else 1


def _to_role_int(r: OrderRole) -> int:
    return 0 if r == OrderRole.EXIT else 1


def _to_side_int(s: Side) -> int:
    return int(s.value)


def _kind_from_int(v: int) -> OrderKind:
    return OrderKind.STOP if v == 0 else OrderKind.LIMIT


def _role_from_int(v: int) -> OrderRole:
    return OrderRole.EXIT if v == 0 else OrderRole.ENTRY


def _side_from_int(v: int) -> Side:
    return Side.BUY if v == 1 else Side.SELL


def _pack_intents(intents: Iterable[OrderIntent]):
    """
    Pack intents into plain arrays for numba.

    Fields:
      order_id: int64
      created_bar: int64
      role: int8 (0=EXIT,1=ENTRY)
      kind: int8 (0=STOP,1=LIMIT)
      side: int8 (1=BUY,-1=SELL)
      price: float64
      qty: int64
    """
    it = list(intents)
    n = len(it)
    order_id = np.empty(n, dtype=np.int64)
    created_bar = np.empty(n, dtype=np.int64)
    role = np.empty(n, dtype=np.int8)
    kind = np.empty(n, dtype=np.int8)
    side = np.empty(n, dtype=np.int8)
    price = np.empty(n, dtype=np.float64)
    qty = np.empty(n, dtype=np.int64)

    for i, x in enumerate(it):
        order_id[i] = int(x.order_id)
        created_bar[i] = int(x.created_bar)
        role[i] = np.int8(_to_role_int(x.role))
        kind[i] = np.int8(_to_kind_int(x.kind))
        side[i] = np.int8(_to_side_int(x.side))
        price[i] = float(x.price)
        qty[i] = int(x.qty)

    return order_id, created_bar, role, kind, side, price, qty


def simulate(
    bars: BarArrays,
    intents: Iterable[OrderIntent],
) -> List[Fill]:
    """
    Phase 2A: JIT accelerated matcher.

    Kill switch:
      - If numba is unavailable OR NUMBA_DISABLE_JIT=1, fall back to Python reference.
    """
    if nb is None:
        return simulate_py(bars, intents)

    # If numba is disabled, keep behavior stable.
    # Numba respects NUMBA_DISABLE_JIT; but we short-circuit to be safe.
    import os

    if os.environ.get("NUMBA_DISABLE_JIT", "").strip() == "1":
        return simulate_py(bars, intents)

    packed = _pack_intents(intents)
    fills_arr = _simulate_kernel(
        bars.open,
        bars.high,
        bars.low,
        packed[0],
        packed[1],
        packed[2],
        packed[3],
        packed[4],
        packed[5],
        packed[6],
    )

    # Convert to Fill objects (drop unused capacity)
    out: List[Fill] = []
    m = fills_arr.shape[0]
    for i in range(m):
        row = fills_arr[i]
        out.append(
            Fill(
                bar_index=int(row[0]),
                role=_role_from_int(int(row[1])),
                kind=_kind_from_int(int(row[2])),
                side=_side_from_int(int(row[3])),
                price=float(row[4]),
                qty=int(row[5]),
                order_id=int(row[6]),
            )
        )
    return out


# ----------------------------
# Numba Kernel
# ----------------------------

if nb is not None:

    @nb.njit(cache=False)
    def _stop_fill(side: int, stop_price: float, o: float, h: float, l: float) -> float:
        # returns nan if no fill
        if side == 1:  # BUY
            if o >= stop_price:
                return o
            if h >= stop_price:
                return stop_price
            return np.nan
        else:  # SELL
            if o <= stop_price:
                return o
            if l <= stop_price:
                return stop_price
            return np.nan

    @nb.njit(cache=False)
    def _limit_fill(side: int, limit_price: float, o: float, h: float, l: float) -> float:
        # returns nan if no fill
        if side == 1:  # BUY
            if o <= limit_price:
                return o
            if l <= limit_price:
                return limit_price
            return np.nan
        else:  # SELL
            if o >= limit_price:
                return o
            if h >= limit_price:
                return limit_price
            return np.nan

    @nb.njit(cache=False)
    def _fill_price(kind: int, side: int, px: float, o: float, h: float, l: float) -> float:
        # kind: 0=STOP, 1=LIMIT
        if kind == 0:
            return _stop_fill(side, px, o, h, l)
        return _limit_fill(side, px, o, h, l)

    @nb.njit(cache=False)
    def _simulate_kernel(
        open_: np.ndarray,
        high: np.ndarray,
        low: np.ndarray,
        order_id: np.ndarray,
        created_bar: np.ndarray,
        role: np.ndarray,
        kind: np.ndarray,
        side: np.ndarray,
        price: np.ndarray,
        qty: np.ndarray,
    ) -> np.ndarray:
        """
        Output columns (float64):
          0 bar_index
          1 role_int (0=EXIT,1=ENTRY)
          2 kind_int (0=STOP,1=LIMIT)
          3 side_int (1=BUY,-1=SELL)
          4 fill_price
          5 qty
          6 order_id
        """
        n_bars = open_.shape[0]
        n_intents = order_id.shape[0]

        # Upper bound on fills: in this Phase 2A reference, at most 2 fills per bar (entry then exit).
        # allocate max and trim later
        max_fills = n_bars * 2
        out = np.empty((max_fills, 7), dtype=np.float64)
        out_n = 0

        pos = 0  # 0 flat, 1 long, -1 short

        for t in range(n_bars):
            o = float(open_[t])
            h = float(high[t])
            l = float(low[t])

            # Collect active intents for this bar (created_bar + 1 == t).
            # We do two passes: entry stage then exit stage.
            # Deterministic selection:
            # - Within ENTRY: STOP first, then order_id asc
            # - Within EXIT:  STOP first, then order_id asc
            # - Same-kind tie: EXIT-first handled by doing exit stage only if pos != 0, after entry stage.
            best_entry_idx = -1
            best_entry_kind = 99
            best_entry_oid = 2**62

            # ENTRY stage selection
            if pos == 0:
                for i in range(n_intents):
                    if created_bar[i] + 1 != t:
                        continue
                    if role[i] != 1:  # ENTRY
                        continue

                    # STOP before LIMIT
                    k = int(kind[i])
                    oid = int(order_id[i])
                    if k < best_entry_kind or (k == best_entry_kind and oid < best_entry_oid):
                        # check fillable
                        fp = _fill_price(k, int(side[i]), float(price[i]), o, h, l)
                        if not np.isnan(fp):
                            best_entry_kind = k
                            best_entry_oid = oid
                            best_entry_idx = i

                if best_entry_idx != -1:
                    i = best_entry_idx
                    fp = _fill_price(int(kind[i]), int(side[i]), float(price[i]), o, h, l)
                    out[out_n, 0] = float(t)
                    out[out_n, 1] = float(role[i])
                    out[out_n, 2] = float(kind[i])
                    out[out_n, 3] = float(side[i])
                    out[out_n, 4] = float(fp)
                    out[out_n, 5] = float(qty[i])
                    out[out_n, 6] = float(order_id[i])
                    out_n += 1

                    # apply position
                    if int(side[i]) == 1:
                        pos = 1
                    else:
                        pos = -1

            # EXIT stage selection (only if in position)
            if pos != 0:
                best_exit_idx = -1
                best_exit_kind = 99
                best_exit_oid = 2**62

                for i in range(n_intents):
                    if created_bar[i] + 1 != t:
                        continue
                    if role[i] != 0:  # EXIT
                        continue

                    # Must be directionally valid:
                    # long exits are SELL, short exits are BUY
                    s = int(side[i])
                    if pos == 1 and s != -1:
                        continue
                    if pos == -1 and s != 1:
                        continue

                    # STOP before LIMIT, then order_id
                    k = int(kind[i])
                    oid = int(order_id[i])
                    if k < best_exit_kind or (k == best_exit_kind and oid < best_exit_oid):
                        fp = _fill_price(k, s, float(price[i]), o, h, l)
                        if not np.isnan(fp):
                            best_exit_kind = k
                            best_exit_oid = oid
                            best_exit_idx = i

                if best_exit_idx != -1:
                    i = best_exit_idx
                    fp = _fill_price(int(kind[i]), int(side[i]), float(price[i]), o, h, l)
                    out[out_n, 0] = float(t)
                    out[out_n, 1] = float(role[i])
                    out[out_n, 2] = float(kind[i])
                    out[out_n, 3] = float(side[i])
                    out[out_n, 4] = float(fp)
                    out[out_n, 5] = float(qty[i])
                    out[out_n, 6] = float(order_id[i])
                    out_n += 1
                    pos = 0

        return out[:out_n]



================================================================================
FILE: src/FishBroWFS_V2/engine/matcher_core.py
================================================================================

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, List, Optional, Tuple

import numpy as np

from FishBroWFS_V2.engine.types import (
    BarArrays,
    Fill,
    OrderIntent,
    OrderKind,
    OrderRole,
    Side,
)


@dataclass
class PositionState:
    """
    Minimal single-position state for Phase 1 tests.
    pos: 0 = flat, 1 = long, -1 = short
    """
    pos: int = 0


def _is_active(intent: OrderIntent, bar_index: int) -> bool:
    return bar_index == intent.created_bar + 1


def _stop_fill_price(side: Side, stop_price: float, o: float, h: float, l: float) -> Optional[float]:
    # Open==price goes to GAP branch by definition.
    if side == Side.BUY:
        if o >= stop_price:
            return o
        if h >= stop_price:
            return stop_price
        return None
    else:
        if o <= stop_price:
            return o
        if l <= stop_price:
            return stop_price
        return None


def _limit_fill_price(side: Side, limit_price: float, o: float, h: float, l: float) -> Optional[float]:
    # Open==price goes to GAP branch by definition.
    if side == Side.BUY:
        if o <= limit_price:
            return o
        if l <= limit_price:
            return limit_price
        return None
    else:
        if o >= limit_price:
            return o
        if h >= limit_price:
            return limit_price
        return None


def _intent_fill_price(intent: OrderIntent, o: float, h: float, l: float) -> Optional[float]:
    if intent.kind == OrderKind.STOP:
        return _stop_fill_price(intent.side, intent.price, o, h, l)
    return _limit_fill_price(intent.side, intent.price, o, h, l)


def _sort_key(intent: OrderIntent) -> Tuple[int, int, int]:
    """
    Deterministic priority:
    1) Role: EXIT first when selecting within same-stage bucket.
    2) Kind: STOP before LIMIT.
    3) order_id: ascending.
    Note: Entry-vs-Exit ordering is handled at a higher level (Entry then Exit).
    """
    role_rank = 0 if intent.role == OrderRole.EXIT else 1
    kind_rank = 0 if intent.kind == OrderKind.STOP else 1
    return (role_rank, kind_rank, intent.order_id)


def simulate(
    bars: BarArrays,
    intents: Iterable[OrderIntent],
) -> List[Fill]:
    """
    Phase 1 slow reference matcher.

    Rules enforced:
    - next-bar active only (bar_index == created_bar + 1)
    - STOP/LIMIT gap behavior at Open
    - STOP over LIMIT
    - Same-bar Entry then Exit
    - Same-kind tie: EXIT-first, order_id ascending
    """
    o = bars.open
    h = bars.high
    l = bars.low
    n = int(o.shape[0])

    intents_list = list(intents)
    fills: List[Fill] = []
    state = PositionState(pos=0)

    for t in range(n):
        ot = float(o[t])
        ht = float(h[t])
        lt = float(l[t])

        active = [x for x in intents_list if _is_active(x, t)]
        if not active:
            continue

        # Partition by role for same-bar entry then exit.
        entry_intents = [x for x in active if x.role == OrderRole.ENTRY]
        exit_intents = [x for x in active if x.role == OrderRole.EXIT]

        # Stage 1: ENTRY stage
        if entry_intents:
            # Among entries: STOP before LIMIT, then order_id.
            entry_sorted = sorted(entry_intents, key=lambda x: (0 if x.kind == OrderKind.STOP else 1, x.order_id))
            for it in entry_sorted:
                if state.pos != 0:
                    break  # single-position only
                px = _intent_fill_price(it, ot, ht, lt)
                if px is None:
                    continue
                fills.append(
                    Fill(
                        bar_index=t,
                        role=it.role,
                        kind=it.kind,
                        side=it.side,
                        price=float(px),
                        qty=int(it.qty),
                        order_id=int(it.order_id),
                    )
                )
                # Apply position change
                if it.side == Side.BUY:
                    state.pos = 1
                else:
                    state.pos = -1
                break  # at most one entry fill per bar in Phase 1 reference

        # Stage 2: EXIT stage (after entry)
        if exit_intents and state.pos != 0:
            # Same-kind tie rule: EXIT-first already, and STOP before LIMIT, then order_id
            exit_sorted = sorted(exit_intents, key=_sort_key)
            for it in exit_sorted:
                # Only allow exits that reduce/close current position in this minimal model:
                # long exits are SELL, short exits are BUY.
                if state.pos == 1 and it.side != Side.SELL:
                    continue
                if state.pos == -1 and it.side != Side.BUY:
                    continue

                px = _intent_fill_price(it, ot, ht, lt)
                if px is None:
                    continue
                fills.append(
                    Fill(
                        bar_index=t,
                        role=it.role,
                        kind=it.kind,
                        side=it.side,
                        price=float(px),
                        qty=int(it.qty),
                        order_id=int(it.order_id),
                    )
                )
                state.pos = 0
                break  # at most one exit fill per bar in Phase 1 reference

    return fills



================================================================================
FILE: src/FishBroWFS_V2/engine/types.py
================================================================================

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Optional

import numpy as np


@dataclass(frozen=True)
class BarArrays:
    open: np.ndarray
    high: np.ndarray
    low: np.ndarray
    close: np.ndarray


class Side(int, Enum):
    BUY = 1
    SELL = -1


class OrderKind(str, Enum):
    STOP = "STOP"
    LIMIT = "LIMIT"


class OrderRole(str, Enum):
    ENTRY = "ENTRY"
    EXIT = "EXIT"


@dataclass(frozen=True)
class OrderIntent:
    """
    Order intent created at bar `created_bar` and becomes active at bar `created_bar + 1`.
    Deterministic ordering is controlled via `order_id` (smaller = earlier).
    """
    order_id: int
    created_bar: int
    role: OrderRole
    kind: OrderKind
    side: Side
    price: float
    qty: int = 1


@dataclass(frozen=True)
class Fill:
    bar_index: int
    role: OrderRole
    kind: OrderKind
    side: Side
    price: float
    qty: int
    order_id: int



================================================================================
FILE: src/FishBroWFS_V2/indicators/__init__.py
================================================================================




================================================================================
FILE: src/FishBroWFS_V2/indicators/numba_indicators.py
================================================================================

from __future__ import annotations

import numpy as np

try:
    import numba as nb
except Exception:  # pragma: no cover
    nb = None  # type: ignore


# ----------------------------
# Rolling Max / Min
# ----------------------------
# Design choice (v1):
# - Simple loop scan for window <= ~50 is cache-friendly and predictable.
# - Correctness first; no deque optimization in v1.


if nb is not None:

    @nb.njit(cache=False)
    def rolling_max(arr: np.ndarray, window: int) -> np.ndarray:
        n = arr.shape[0]
        out = np.full(n, np.nan, dtype=np.float64)
        if window <= 0:
            return out
        for i in range(n):
            start = i - window + 1
            if start < 0:
                start = 0
            m = arr[start]
            for j in range(start + 1, i + 1):
                v = arr[j]
                if v > m:
                    m = v
            out[i] = m
        return out

    @nb.njit(cache=False)
    def rolling_min(arr: np.ndarray, window: int) -> np.ndarray:
        n = arr.shape[0]
        out = np.full(n, np.nan, dtype=np.float64)
        if window <= 0:
            return out
        for i in range(n):
            start = i - window + 1
            if start < 0:
                start = 0
            m = arr[start]
            for j in range(start + 1, i + 1):
                v = arr[j]
                if v < m:
                    m = v
            out[i] = m
        return out

else:
    # Fallback pure-python (used only if numba unavailable)
    def rolling_max(arr: np.ndarray, window: int) -> np.ndarray:  # type: ignore
        n = arr.shape[0]
        out = np.full(n, np.nan, dtype=np.float64)
        if window <= 0:
            return out
        for i in range(n):
            start = max(0, i - window + 1)
            out[i] = np.max(arr[start : i + 1])
        return out

    def rolling_min(arr: np.ndarray, window: int) -> np.ndarray:  # type: ignore
        n = arr.shape[0]
        out = np.full(n, np.nan, dtype=np.float64)
        if window <= 0:
            return out
        for i in range(n):
            start = max(0, i - window + 1)
            out[i] = np.min(arr[start : i + 1])
        return out


# ----------------------------
# ATR (Wilder's RMA)
# ----------------------------
# Definition:
# TR[t] = max(high[t]-low[t], abs(high[t]-close[t-1]), abs(low[t]-close[t-1]))
# ATR[t] = (ATR[t-1]*(n-1) + TR[t]) / n
# Notes:
# - Recursive; must keep state.
# - First ATR uses simple average of first n TRs.


if nb is not None:

    @nb.njit(cache=False)
    def atr_wilder(high: np.ndarray, low: np.ndarray, close: np.ndarray, window: int) -> np.ndarray:
        n = high.shape[0]
        out = np.full(n, np.nan, dtype=np.float64)
        if window <= 0 or n == 0:
            return out
        if window > n:
            return out

        # TR computation
        tr = np.empty(n, dtype=np.float64)
        tr[0] = high[0] - low[0]
        for i in range(1, n):
            a = high[i] - low[i]
            b = abs(high[i] - close[i - 1])
            c = abs(low[i] - close[i - 1])
            tr[i] = a if a >= b and a >= c else (b if b >= c else c)

        # initial ATR: simple average of first window TRs
        s = 0.0
        end = window if window < n else n
        for i in range(end):
            s += tr[i]
        # here window <= n guaranteed
        out[end - 1] = s / window

        # Wilder smoothing
        for i in range(window, n):
            out[i] = (out[i - 1] * (window - 1) + tr[i]) / window

        return out

else:
    def atr_wilder(high: np.ndarray, low: np.ndarray, close: np.ndarray, window: int) -> np.ndarray:  # type: ignore
        n = high.shape[0]
        out = np.full(n, np.nan, dtype=np.float64)
        if window <= 0 or n == 0:
            return out
        if window > n:
            return out

        tr = np.empty(n, dtype=np.float64)
        tr[0] = high[0] - low[0]
        for i in range(1, n):
            tr[i] = max(
                high[i] - low[i],
                abs(high[i] - close[i - 1]),
                abs(low[i] - close[i - 1]),
            )

        end = min(window, n)
        # window <= n guaranteed
        out[end - 1] = np.mean(tr[:end])
        for i in range(window, n):
            out[i] = (out[i - 1] * (window - 1) + tr[i]) / window
        return out



================================================================================
FILE: src/FishBroWFS_V2/pipeline/__init__.py
================================================================================




================================================================================
FILE: src/FishBroWFS_V2/pipeline/param_sort.py
================================================================================

from __future__ import annotations

import numpy as np


def sort_params_cache_friendly(params: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    """
    Cache-friendly sorting for parameter matrix.

    params: shape (n, k) float64.
      Convention (Phase 3B v1):
        col0 = channel_len
        col1 = atr_len
        col2 = stop_mult

    Returns:
      sorted_params: params reordered (view/copy depending on numpy)
      order: indices such that sorted_params = params[order]
    """
    if params.ndim != 2 or params.shape[1] < 3:
        raise ValueError("params must be (n, >=3) array")

    # Primary: channel_len (int-like)
    # Secondary: atr_len (int-like)
    # Tertiary: stop_mult
    ch = params[:, 0]
    atr = params[:, 1]
    sm = params[:, 2]

    order = np.lexsort((sm, atr, ch))
    return params[order], order



================================================================================
FILE: src/FishBroWFS_V2/pipeline/runner_grid.py
================================================================================

from __future__ import annotations

from typing import Dict, Tuple

import numpy as np

from FishBroWFS_V2.data.layout import normalize_bars
from FishBroWFS_V2.engine.types import BarArrays
from FishBroWFS_V2.pipeline.param_sort import sort_params_cache_friendly
from FishBroWFS_V2.strategy.kernel import DonchianAtrParams, run_kernel


def _ensure_contiguous_bars(bars: BarArrays) -> BarArrays:
    if bars.open.flags["C_CONTIGUOUS"] and bars.high.flags["C_CONTIGUOUS"] and bars.low.flags["C_CONTIGUOUS"] and bars.close.flags["C_CONTIGUOUS"]:
        return bars
    return BarArrays(
        open=np.ascontiguousarray(bars.open, dtype=np.float64),
        high=np.ascontiguousarray(bars.high, dtype=np.float64),
        low=np.ascontiguousarray(bars.low, dtype=np.float64),
        close=np.ascontiguousarray(bars.close, dtype=np.float64),
    )


def run_grid(
    open_: np.ndarray,
    high: np.ndarray,
    low: np.ndarray,
    close: np.ndarray,
    params_matrix: np.ndarray,
    *,
    commission: float,
    slip: float,
    order_qty: int = 1,
    sort_params: bool = True,
) -> Dict[str, object]:
    """
    Phase 3B v1: Dynamic Grid Runner (homology locked).

    params_matrix: shape (n, >=3) float64
      col0 channel_len (int-like)
      col1 atr_len (int-like)
      col2 stop_mult (float)

    Returns:
      dict with:
        - metrics: np.ndarray shape (n, 3) float64 columns:
            [net_profit, trades, max_dd]
        - order: np.ndarray indices mapping output rows back to original params (or identity)
    """
    bars = _ensure_contiguous_bars(normalize_bars(open_, high, low, close))

    if params_matrix.ndim != 2 or params_matrix.shape[1] < 3:
        raise ValueError("params_matrix must be (n, >=3)")

    pm = np.asarray(params_matrix, dtype=np.float64)
    if sort_params:
        pm_sorted, order = sort_params_cache_friendly(pm)
    else:
        pm_sorted = pm
        order = np.arange(pm.shape[0], dtype=np.int64)

    n = pm_sorted.shape[0]
    metrics = np.zeros((n, 3), dtype=np.float64)

    # Homology: only call run_kernel, never compute strategy/metrics here.
    for i in range(n):
        ch = int(pm_sorted[i, 0])
        atr = int(pm_sorted[i, 1])
        sm = float(pm_sorted[i, 2])

        out = run_kernel(
            bars,
            DonchianAtrParams(channel_len=ch, atr_len=atr, stop_mult=sm),
            commission=float(commission),
            slip=float(slip),
            order_qty=int(order_qty),
        )

        m = out["metrics"]
        # Zero-trade safe: kernel guarantees valid numbers (0.0/0)
        metrics[i, 0] = float(m["net_profit"])
        metrics[i, 1] = float(m["trades"])
        metrics[i, 2] = float(m["max_dd"])

    return {"metrics": metrics, "order": order}



================================================================================
FILE: src/FishBroWFS_V2/strategy/__init__.py
================================================================================




================================================================================
FILE: src/FishBroWFS_V2/strategy/kernel.py
================================================================================

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Tuple

import numpy as np

from FishBroWFS_V2.engine.engine_jit import simulate as simulate_matcher
from FishBroWFS_V2.engine.types import BarArrays, Fill, OrderIntent, OrderKind, OrderRole, Side
from FishBroWFS_V2.indicators.numba_indicators import rolling_max, atr_wilder


@dataclass(frozen=True)
class DonchianAtrParams:
    channel_len: int
    atr_len: int
    stop_mult: float


def _max_drawdown(equity: np.ndarray) -> float:
    """
    Vectorized max drawdown on an equity curve.
    Handles empty arrays gracefully.
    """
    if equity.size == 0:
        return 0.0
    peak = np.maximum.accumulate(equity)
    dd = equity - peak
    mdd = float(np.min(dd))  # negative or 0
    return mdd


def run_kernel(
    bars: BarArrays,
    params: DonchianAtrParams,
    *,
    commission: float,
    slip: float,
    order_qty: int = 1,
) -> Dict[str, object]:
    """
    Golden Kernel (GKV): single-source-of-truth kernel for Phase 3A and future Phase 3B.

    Strategy (minimal):
      - Entry: Buy Stop at Donchian High (rolling max of HIGH over channel_len) at bar close -> next bar active.
      - Exit: Sell Stop at (entry_fill_price - stop_mult * ATR_wilder) active from next bar after entry_fill.

    Costs:
      - commission (absolute per trade)
      - slip (absolute per trade)
      Costs are applied on each round-trip fill (entry and exit each incur cost).

    Returns:
      dict with:
        - fills: List[Fill]
        - pnl: np.ndarray (float64, per-round-trip pnl, can be empty)
        - equity: np.ndarray (float64, cumsum of pnl, can be empty)
        - metrics: dict (net_profit, trades, max_dd)
    """
    # --- Compute indicators (kernel level; wrapper must ensure contiguous arrays) ---
    ch = int(params.channel_len)
    atr_n = int(params.atr_len)
    stop_mult = float(params.stop_mult)

    if ch <= 0 or atr_n <= 0:
        # invalid params -> zero trades, deterministic
        pnl = np.empty(0, dtype=np.float64)
        equity = np.empty(0, dtype=np.float64)
        return {
            "fills": [],
            "pnl": pnl,
            "equity": equity,
            "metrics": {"net_profit": 0.0, "trades": 0, "max_dd": 0.0},
        }

    donch_hi = rolling_max(bars.high, ch)  # includes current bar
    atr = atr_wilder(bars.high, bars.low, bars.close, atr_n)

    # --- Build order intents (next-bar active) ---
    intents: List[OrderIntent] = []
    oid = 1

    # We create entry intents for each bar t where indicator exists:
    # created_bar=t, active at t+1. price=donch_hi[t]
    n = int(bars.open.shape[0])
    for t in range(n):
        px = float(donch_hi[t])
        if np.isnan(px):
            continue
        intents.append(
            OrderIntent(
                order_id=oid,
                created_bar=t,
                role=OrderRole.ENTRY,
                kind=OrderKind.STOP,
                side=Side.BUY,
                price=px,
                qty=order_qty,
            )
        )
        oid += 1

    # Run matcher (JIT or python via kill-switch)
    fills: List[Fill] = simulate_matcher(bars, intents)

    # --- Convert fills -> round-trip pnl (vectorized style, no python trade loops as truth) ---
    # For this minimal kernel we assume:
    # - Only LONG trades (BUY entry, SELL exit) will be produced once we add exits.
    # Phase 3A GKV: We implement exits by post-processing: when entry fills, schedule a sell stop from next bar.
    # To preserve Homology, we do a second matcher pass with generated exit intents.
    # This keeps all fill semantics inside the matcher (constitution).
    exit_intents: List[OrderIntent] = []
    for f in fills:
        if f.role != OrderRole.ENTRY:
            continue
        # exit stop price = entry_price - stop_mult * atr at entry bar
        ebar = int(f.bar_index)
        if ebar < 0 or ebar >= n:
            continue
        a = float(atr[ebar])
        if np.isnan(a):
            continue
        stop_px = float(f.price - stop_mult * a)
        exit_intents.append(
            OrderIntent(
                order_id=oid,
                created_bar=ebar,  # active next bar
                role=OrderRole.EXIT,
                kind=OrderKind.STOP,
                side=Side.SELL,
                price=stop_px,
                qty=order_qty,
            )
        )
        oid += 1

    if exit_intents:
        fills2 = simulate_matcher(bars, exit_intents)
        fills_all = fills + fills2
        # deterministic order: sort by (bar_index, role(ENTRY first), kind, order_id)
        fills_all.sort(key=lambda x: (x.bar_index, 0 if x.role == OrderRole.ENTRY else 1, 0 if x.kind == OrderKind.STOP else 1, x.order_id))
    else:
        fills_all = fills

    # Extract entry/exit prices for round trips (vectorized with arrays, but pairing is minimal 1:1 sequential)
    # Pairing rule for GKV v1: take fills in chronological order, pair BUY(ENTRY) then SELL(EXIT).
    entry_prices = []
    exit_prices = []
    for f in fills_all:
        if f.role == OrderRole.ENTRY and f.side == Side.BUY:
            entry_prices.append(float(f.price))
        elif f.role == OrderRole.EXIT and f.side == Side.SELL:
            exit_prices.append(float(f.price))

    k = min(len(entry_prices), len(exit_prices))
    if k == 0:
        pnl = np.empty(0, dtype=np.float64)
        equity = np.empty(0, dtype=np.float64)
        metrics = {"net_profit": 0.0, "trades": 0, "max_dd": 0.0}
        return {"fills": fills_all, "pnl": pnl, "equity": equity, "metrics": metrics}

    ep = np.asarray(entry_prices[:k], dtype=np.float64)
    xp = np.asarray(exit_prices[:k], dtype=np.float64)

    # Costs applied per fill (entry + exit)
    costs = (float(commission) + float(slip)) * 2.0
    pnl = (xp - ep) * float(order_qty) - costs
    equity = np.cumsum(pnl)

    metrics = {
        "net_profit": float(np.sum(pnl)) if pnl.size else 0.0,
        "trades": int(pnl.size),
        "max_dd": _max_drawdown(equity),
    }
    return {"fills": fills_all, "pnl": pnl, "equity": equity, "metrics": metrics}



================================================================================
FILE: src/FishBroWFS_V2/strategy/runner_single.py
================================================================================

from __future__ import annotations

from typing import Dict

import numpy as np

from FishBroWFS_V2.data.layout import normalize_bars
from FishBroWFS_V2.engine.types import BarArrays
from FishBroWFS_V2.strategy.kernel import DonchianAtrParams, run_kernel


def run_single(
    open_: np.ndarray,
    high: np.ndarray,
    low: np.ndarray,
    close: np.ndarray,
    params: DonchianAtrParams,
    *,
    commission: float,
    slip: float,
    order_qty: int = 1,
) -> Dict[str, object]:
    """
    Wrapper for Phase 3A (GKV): ensure memory layout + call kernel once.
    """
    bars: BarArrays = normalize_bars(open_, high, low, close)

    # Boundary Layout Check: enforce contiguous arrays before entering kernel.
    if not bars.open.flags["C_CONTIGUOUS"]:
        bars = BarArrays(
            open=np.ascontiguousarray(bars.open, dtype=np.float64),
            high=np.ascontiguousarray(bars.high, dtype=np.float64),
            low=np.ascontiguousarray(bars.low, dtype=np.float64),
            close=np.ascontiguousarray(bars.close, dtype=np.float64),
        )

    return run_kernel(bars, params, commission=commission, slip=slip, order_qty=order_qty)



================================================================================
FILE: src/FishBroWFS_V2/version.py
================================================================================

__version__ = "0.1.0"



================================================================================
FILE: tests/test_baseline_lock.py
================================================================================

import numpy as np

from FishBroWFS_V2.data.layout import normalize_bars
from FishBroWFS_V2.engine.engine_jit import simulate as simulate_jit
from FishBroWFS_V2.engine.matcher_core import simulate as simulate_py
from FishBroWFS_V2.engine.types import OrderIntent, OrderKind, OrderRole, Side


def _fills_to_matrix(fills):
    # Columns: bar_index, role, kind, side, price, qty, order_id
    m = np.empty((len(fills), 7), dtype=np.float64)
    for i, f in enumerate(fills):
        m[i, 0] = float(f.bar_index)
        m[i, 1] = 0.0 if f.role == OrderRole.EXIT else 1.0
        m[i, 2] = 0.0 if f.kind == OrderKind.STOP else 1.0
        m[i, 3] = float(int(f.side.value))
        m[i, 4] = float(f.price)
        m[i, 5] = float(f.qty)
        m[i, 6] = float(f.order_id)
    return m


def test_gate_a_jit_matches_python_reference():
    # Two bars so we can test next-bar active + entry then exit.
    bars = normalize_bars(
        np.array([100.0, 100.0], dtype=np.float64),
        np.array([120.0, 120.0], dtype=np.float64),
        np.array([90.0, 80.0], dtype=np.float64),
        np.array([110.0, 90.0], dtype=np.float64),
    )

    intents = [
        # Entry active on bar0
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=105.0),
        # Exit active on bar0 (same bar), should execute after entry
        OrderIntent(order_id=2, created_bar=-1, role=OrderRole.EXIT, kind=OrderKind.STOP, side=Side.SELL, price=95.0),
        # Entry created on bar0 -> active on bar1
        OrderIntent(order_id=3, created_bar=0, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=110.0),
    ]

    py = simulate_py(bars, intents)
    jit = simulate_jit(bars, intents)

    m_py = _fills_to_matrix(py)
    m_jit = _fills_to_matrix(jit)

    assert m_py.shape == m_jit.shape
    # Event-level exactness except price tolerance
    np.testing.assert_array_equal(m_py[:, [0, 1, 2, 3, 5, 6]], m_jit[:, [0, 1, 2, 3, 5, 6]])
    np.testing.assert_allclose(m_py[:, 4], m_jit[:, 4], rtol=0.0, atol=1e-9)



================================================================================
FILE: tests/test_data_layout.py
================================================================================

import numpy as np
import pytest
from FishBroWFS_V2.data.layout import normalize_bars


def test_normalize_bars_dtype_and_contiguous():
    o = np.arange(10, dtype=np.float32)[::2]
    h = o + 1
    l = o - 1
    c = o + 0.5

    bars = normalize_bars(o, h, l, c)

    for arr in (bars.open, bars.high, bars.low, bars.close):
        assert arr.dtype == np.float64
        assert arr.flags["C_CONTIGUOUS"]


def test_normalize_bars_reject_nan():
    o = np.array([1.0, np.nan])
    h = np.array([1.0, 2.0])
    l = np.array([0.5, 1.5])
    c = np.array([0.8, 1.8])

    with pytest.raises(ValueError):
        normalize_bars(o, h, l, c)



================================================================================
FILE: tests/test_engine_constitution.py
================================================================================

import numpy as np

from FishBroWFS_V2.data.layout import normalize_bars
from FishBroWFS_V2.engine.matcher_core import simulate
from FishBroWFS_V2.engine.types import OrderIntent, OrderKind, OrderRole, Side


def _bars1(o, h, l, c):
    return normalize_bars(
        np.array([o], dtype=np.float64),
        np.array([h], dtype=np.float64),
        np.array([l], dtype=np.float64),
        np.array([c], dtype=np.float64),
    )


def _bars2(o0, h0, l0, c0, o1, h1, l1, c1):
    return normalize_bars(
        np.array([o0, o1], dtype=np.float64),
        np.array([h0, h1], dtype=np.float64),
        np.array([l0, l1], dtype=np.float64),
        np.array([c0, c1], dtype=np.float64),
    )


def test_tc01_buy_stop_normal():
    bars = _bars1(90, 105, 90, 100)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=100.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 1
    assert fills[0].price == 100.0


def test_tc02_buy_stop_gap_up_fill_open():
    bars = _bars1(105, 110, 105, 108)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=100.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 1
    assert fills[0].price == 105.0


def test_tc03_sell_stop_gap_down_fill_open():
    bars = _bars1(90, 95, 80, 85)
    intents = [
        # Exit a long position requires SELL stop; we will enter long first in same bar is not allowed here,
        # so we simulate already-in-position by forcing an entry earlier: created_bar=-2 triggers at -1 (ignored),
        # Instead: use two bars and enter on bar0, exit on bar1.
    ]
    bars2 = _bars2(
        100, 100, 100, 100,   # bar0: enter long at 100 (buy stop gap/normal both ok)
        90, 95, 80, 85        # bar1: exit stop triggers gap down open
    )
    intents2 = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=100.0),
        OrderIntent(order_id=2, created_bar=0, role=OrderRole.EXIT, kind=OrderKind.STOP, side=Side.SELL, price=100.0),
    ]
    fills = simulate(bars2, intents2)
    assert len(fills) == 2
    # second fill is the exit
    assert fills[1].price == 90.0


def test_tc08_next_bar_active_not_same_bar():
    # bar0 has high 105 which would hit stop 102, but order created at bar0 must not fill at bar0.
    # bar1 hits again, should fill at bar1.
    bars = _bars2(
        100, 105, 95, 100,
        100, 105, 95, 100,
    )
    intents = [
        OrderIntent(order_id=1, created_bar=0, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=102.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 1
    assert fills[0].bar_index == 1
    assert fills[0].price == 102.0


def test_tc09_open_equals_stop_gap_branch_but_same_price():
    bars = _bars1(100, 100, 90, 95)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=100.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 1
    assert fills[0].price == 100.0


def test_tc10_no_fill_when_not_touched():
    bars = _bars1(90, 95, 90, 92)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=100.0),
    ]
    fills = simulate(bars, intents)
    assert fills == []



================================================================================
FILE: tests/test_engine_gaps_and_priority.py
================================================================================

import numpy as np

from FishBroWFS_V2.data.layout import normalize_bars
from FishBroWFS_V2.engine.matcher_core import simulate
from FishBroWFS_V2.engine.types import OrderIntent, OrderKind, OrderRole, Side


def _bars1(o, h, l, c):
    return normalize_bars(
        np.array([o], dtype=np.float64),
        np.array([h], dtype=np.float64),
        np.array([l], dtype=np.float64),
        np.array([c], dtype=np.float64),
    )


def test_tc04_buy_limit_gap_down_better_fill_open():
    bars = _bars1(90, 95, 85, 92)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.LIMIT, side=Side.BUY, price=100.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 1
    assert fills[0].price == 90.0


def test_tc05_sell_limit_gap_up_better_fill_open():
    bars = _bars1(105, 110, 100, 108)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.LIMIT, side=Side.SELL, price=100.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 1
    assert fills[0].price == 105.0


def test_tc06_priority_stop_wins_over_limit_on_exit():
    # First enter long on this same bar, then exit on next bar where both stop and limit are triggerable.
    # Bar0: enter long at 100 (buy stop hits)
    # Bar1: both exit stop 90 and exit limit 110 are touchable (high=110, low=80), STOP must win (fill=90)
    bars = normalize_bars(
        np.array([100, 100], dtype=np.float64),
        np.array([110, 110], dtype=np.float64),
        np.array([90, 80], dtype=np.float64),
        np.array([100, 90], dtype=np.float64),
    )

    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=100.0),
        OrderIntent(order_id=2, created_bar=0, role=OrderRole.EXIT, kind=OrderKind.STOP, side=Side.SELL, price=90.0),
        OrderIntent(order_id=3, created_bar=0, role=OrderRole.EXIT, kind=OrderKind.LIMIT, side=Side.SELL, price=110.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 2
    # Second fill is exit; STOP wins -> 90
    assert fills[1].kind == OrderKind.STOP
    assert fills[1].price == 90.0


def test_tc07_same_bar_entry_then_exit():
    # Same bar allows Entry then Exit.
    # Bar: O=100 H=120 L=90 C=110
    # Entry: Buy Stop 105 -> fills at 105 (since open 100 < 105 and high 120 >= 105)
    # Exit: Sell Stop 95 -> after entry, low 90 <= 95 -> fills at 95
    bars = _bars1(100, 120, 90, 110)
    intents = [
        OrderIntent(order_id=1, created_bar=-1, role=OrderRole.ENTRY, kind=OrderKind.STOP, side=Side.BUY, price=105.0),
        OrderIntent(order_id=2, created_bar=-1, role=OrderRole.EXIT, kind=OrderKind.STOP, side=Side.SELL, price=95.0),
    ]
    fills = simulate(bars, intents)
    assert len(fills) == 2
    assert fills[0].price == 105.0
    assert fills[1].price == 95.0



================================================================================
FILE: tests/test_golden_kernel_verification.py
================================================================================

import numpy as np

from FishBroWFS_V2.strategy.kernel import DonchianAtrParams, run_kernel, _max_drawdown
from FishBroWFS_V2.engine.types import BarArrays


def _bars():
    # Small synthetic OHLC series
    o = np.array([100, 101, 102, 103, 104, 105], dtype=np.float64)
    h = np.array([101, 102, 103, 104, 106, 107], dtype=np.float64)
    l = np.array([99, 100, 101, 102, 103, 104], dtype=np.float64)
    c = np.array([100.5, 101.5, 102.5, 103.5, 105.5, 106.5], dtype=np.float64)
    return BarArrays(open=o, high=h, low=l, close=c)


def test_no_trade_case_does_not_crash_and_returns_zero_metrics():
    bars = _bars()
    params = DonchianAtrParams(channel_len=99999, atr_len=3, stop_mult=2.0)

    out = run_kernel(bars, params, commission=0.0, slip=0.0, order_qty=1)
    pnl = out["pnl"]
    equity = out["equity"]
    metrics = out["metrics"]

    assert isinstance(pnl, np.ndarray)
    assert pnl.size == 0
    assert isinstance(equity, np.ndarray)
    assert equity.size == 0
    assert metrics["net_profit"] == 0.0
    assert metrics["trades"] == 0
    assert metrics["max_dd"] == 0.0


def test_vectorized_metrics_are_self_consistent():
    bars = _bars()
    params = DonchianAtrParams(channel_len=2, atr_len=2, stop_mult=1.0)

    out = run_kernel(bars, params, commission=0.0, slip=0.0, order_qty=1)
    pnl = out["pnl"]
    equity = out["equity"]
    metrics = out["metrics"]

    # If zero trades, still must be consistent
    if pnl.size == 0:
        assert metrics["net_profit"] == 0.0
        assert metrics["trades"] == 0
        assert metrics["max_dd"] == 0.0
        return

    # Vectorized checks
    np.testing.assert_allclose(equity, np.cumsum(pnl), rtol=0.0, atol=0.0)
    assert metrics["trades"] == int(pnl.size)
    assert metrics["net_profit"] == float(np.sum(pnl))
    assert metrics["max_dd"] == _max_drawdown(equity)


def test_costs_are_parameterized_not_hardcoded():
    bars = _bars()
    params = DonchianAtrParams(channel_len=2, atr_len=2, stop_mult=1.0)

    out0 = run_kernel(bars, params, commission=0.0, slip=0.0, order_qty=1)
    out1 = run_kernel(bars, params, commission=1.25, slip=0.75, order_qty=1)

    pnl0 = out0["pnl"]
    pnl1 = out1["pnl"]

    # Either both empty or both non-empty; if empty, pass
    if pnl0.size == 0:
        assert pnl1.size == 0
        return

    # Costs increase => pnl decreases by 2*(commission+slip) per trade
    per_trade_delta = 2.0 * (1.25 + 0.75)
    np.testing.assert_allclose(pnl1, pnl0 - per_trade_delta, rtol=0.0, atol=1e-12)



================================================================================
FILE: tests/test_grid_runner_smoke.py
================================================================================

import numpy as np

from FishBroWFS_V2.pipeline.runner_grid import run_grid


def _ohlc():
    o = np.array([100, 101, 102, 103, 104, 105], dtype=np.float64)
    h = np.array([101, 102, 103, 104, 106, 107], dtype=np.float64)
    l = np.array([99, 100, 101, 102, 103, 104], dtype=np.float64)
    c = np.array([100.5, 101.5, 102.5, 103.5, 105.5, 106.5], dtype=np.float64)
    return o, h, l, c


def test_grid_runner_smoke_shapes_and_no_crash():
    o, h, l, c = _ohlc()

    # params: [channel_len, atr_len, stop_mult]
    params = np.array(
        [
            [2, 2, 1.0],
            [3, 2, 1.5],
            [99999, 3, 2.0],  # should produce 0 trades
            [2, 99999, 2.0],  # atr_len > n should be safe (atr_wilder returns all-NaN -> kernel => 0 trades)
        ],
        dtype=np.float64,
    )

    out = run_grid(o, h, l, c, params, commission=0.0, slip=0.0, order_qty=1, sort_params=True)
    m = out["metrics"]
    order = out["order"]

    assert isinstance(m, np.ndarray)
    assert m.shape == (params.shape[0], 3)
    assert isinstance(order, np.ndarray)
    assert order.shape == (params.shape[0],)
    assert set(order.tolist()) == set(range(params.shape[0]))
    # Optional stronger assertion: at least one row should have 0 trades due to atr_len > n
    assert np.any(m[:, 1] == 0.0)


def test_grid_runner_sorting_toggle():
    o, h, l, c = _ohlc()
    params = np.array(
        [
            [3, 2, 1.5],
            [2, 2, 1.0],
            [2, 3, 2.0],
        ],
        dtype=np.float64,
    )

    out_sorted = run_grid(o, h, l, c, params, commission=0.0, slip=0.0, order_qty=1, sort_params=True)
    out_unsorted = run_grid(o, h, l, c, params, commission=0.0, slip=0.0, order_qty=1, sort_params=False)

    assert out_sorted["metrics"].shape == out_unsorted["metrics"].shape == (3, 3)
    assert out_sorted["order"].shape == out_unsorted["order"].shape == (3,)
    # unsorted order should be identity
    np.testing.assert_array_equal(out_unsorted["order"], np.array([0, 1, 2], dtype=np.int64))



================================================================================
FILE: tests/test_indicators_consistency.py
================================================================================

import numpy as np

from FishBroWFS_V2.indicators.numba_indicators import (
    rolling_max,
    rolling_min,
    atr_wilder,
)


def _py_rolling_max(arr, window):
    out = np.full(len(arr), np.nan, dtype=np.float64)
    for i in range(len(arr)):
        start = max(0, i - window + 1)
        out[i] = np.max(arr[start : i + 1])
    return out


def _py_rolling_min(arr, window):
    out = np.full(len(arr), np.nan, dtype=np.float64)
    for i in range(len(arr)):
        start = max(0, i - window + 1)
        out[i] = np.min(arr[start : i + 1])
    return out


def _py_atr_wilder(high, low, close, window):
    n = len(high)
    out = np.full(n, np.nan, dtype=np.float64)
    if window > n:
        return out
    tr = np.empty(n, dtype=np.float64)
    tr[0] = high[0] - low[0]
    for i in range(1, n):
        tr[i] = max(
            high[i] - low[i],
            abs(high[i] - close[i - 1]),
            abs(low[i] - close[i - 1]),
        )
    end = window
    out[end - 1] = np.mean(tr[:end])
    for i in range(window, n):
        out[i] = (out[i - 1] * (window - 1) + tr[i]) / window
    return out


def test_rolling_max_min_consistency():
    arr = np.array([1.0, 3.0, 2.0, 5.0, 4.0], dtype=np.float64)
    w = 3

    mx_py = _py_rolling_max(arr, w)
    mn_py = _py_rolling_min(arr, w)

    mx = rolling_max(arr, w)
    mn = rolling_min(arr, w)

    np.testing.assert_allclose(mx, mx_py, rtol=0.0, atol=0.0)
    np.testing.assert_allclose(mn, mn_py, rtol=0.0, atol=0.0)


def test_atr_wilder_consistency():
    high = np.array([10, 11, 12, 11, 13, 14], dtype=np.float64)
    low = np.array([9, 9, 10, 9, 11, 12], dtype=np.float64)
    close = np.array([9.5, 10.5, 11.0, 10.0, 12.0, 13.0], dtype=np.float64)
    w = 3

    atr_py = _py_atr_wilder(high, low, close, w)
    atr = atr_wilder(high, low, close, w)

    np.testing.assert_allclose(atr, atr_py, rtol=0.0, atol=1e-12)


def test_atr_wilder_window_gt_n_returns_all_nan():
    high = np.array([10, 11], dtype=np.float64)
    low = np.array([9, 10], dtype=np.float64)
    close = np.array([9.5, 10.5], dtype=np.float64)
    atr = atr_wilder(high, low, close, 999)
    assert atr.shape == (2,)
    assert np.all(np.isnan(atr))


