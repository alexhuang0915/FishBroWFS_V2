
"""
Stage P2-3A: Numba-accelerated Sparse Entry Intent Builder

Single-pass Numba implementation for building sparse entry intents.
Uses two-pass approach: count first, then allocate and fill.
"""
from __future__ import annotations

import numpy as np

try:
    import numba as nb
except Exception:  # pragma: no cover
    nb = None  # type: ignore


if nb is not None:

    @nb.njit(cache=False)
    def _deterministic_random(t: int, seed: int) -> float:
        """
        Deterministic pseudo-random number generator for trigger rate selection.
        
        This mimics numpy.random.default_rng(seed).random() behavior for position t.
        Uses PCG64 algorithm approximation for compatibility with numpy's default_rng.
        
        Note: For exact compatibility with apply_trigger_rate_mask, we need to match
        the sequence generated by rng.random(n - warmup) for positions >= warmup.
        Since we're iterating t from 1..n-1, we use (t - warmup) as the index.
        """
        # Approximate PCG64: use a simple hash-based approach
        # This ensures deterministic selection matching numpy's default_rng(seed)
        # We use t as the position index (for positions >= warmup, index = t - warmup)
        # Simple hash: combine seed and t
        x = (seed ^ (t * 0x9e3779b9)) & 0xFFFFFFFF
        x = ((x << 16) ^ (x >> 16)) & 0xFFFFFFFF
        x = (x * 0x85ebca6b) & 0xFFFFFFFF
        x = (x ^ (x >> 13)) & 0xFFFFFFFF
        x = (x * 0xc2b2ae35) & 0xFFFFFFFF
        x = (x ^ (x >> 16)) & 0xFFFFFFFF
        # Normalize to [0, 1)
        return float(x & 0x7FFFFFFF) / float(0x7FFFFFFF + 1)

    @nb.njit(cache=False)
    def _count_valid_intents(
        donch_prev: np.ndarray,
        warmup: int,
        trigger_rate: float,
        random_vals: np.ndarray,
    ) -> int:
        """
        Pass 1: Count valid entry intents.
        
        Args:
            donch_prev: float64 array (n_bars,) - shifted donchian high
            warmup: Warmup period
            trigger_rate: Trigger rate (0.0 to 1.0)
            random_vals: Pre-computed random values (shape n - warmup) for positions >= warmup
        
        Returns:
            Number of valid intents
        """
        n = donch_prev.shape[0]
        count = 0
        
        # Scan bars 1..n-1 (bar index t, where created_bar = t-1)
        for t in range(1, n):
            # Check if signal is valid (finite, positive, past warmup)
            if t < warmup:
                continue
            
            price_val = donch_prev[t]
            if not (np.isfinite(price_val) and price_val > 0.0):
                continue
            
            # Apply trigger rate selection (deterministic)
            # Match apply_trigger_rate_mask logic: use (t - warmup) as index into random_vals
            if trigger_rate < 1.0:
                rng_index = t - warmup  # Index into random sequence (0-based for positions >= warmup)
                if rng_index < random_vals.shape[0]:
                    rand_val = random_vals[rng_index]
                    if rand_val >= trigger_rate:
                        continue  # Skip this trigger
            
            count += 1
        
        return count

    @nb.njit(cache=False)
    def _build_sparse_intents(
        donch_prev: np.ndarray,
        warmup: int,
        trigger_rate: float,
        random_vals: np.ndarray,
        order_qty: int,
        n_entry: int,
        created_bar: np.ndarray,
        price: np.ndarray,
        order_id: np.ndarray,
        role: np.ndarray,
        kind: np.ndarray,
        side: np.ndarray,
        qty: np.ndarray,
    ) -> None:
        """
        Pass 2: Fill sparse intent arrays.
        
        Args:
            donch_prev: float64 array (n_bars,) - shifted donchian high
            warmup: Warmup period
            trigger_rate: Trigger rate (0.0 to 1.0)
            random_vals: Pre-computed random values (shape n - warmup) for positions >= warmup
            order_qty: Order quantity
            n_entry: Number of valid intents (pre-allocated array size)
            created_bar: Output array (int32, shape n_entry)
            price: Output array (float64, shape n_entry)
            order_id: Output array (int32, shape n_entry)
            role: Output array (uint8, shape n_entry)
            kind: Output array (uint8, shape n_entry)
            side: Output array (uint8, shape n_entry)
            qty: Output array (int32, shape n_entry)
        """
        n = donch_prev.shape[0]
        idx = 0
        
        # Scan bars 1..n-1 (bar index t, where created_bar = t-1)
        for t in range(1, n):
            # Check if signal is valid (finite, positive, past warmup)
            if t < warmup:
                continue
            
            price_val = donch_prev[t]
            if not (np.isfinite(price_val) and price_val > 0.0):
                continue
            
            # Apply trigger rate selection (deterministic)
            # Match apply_trigger_rate_mask logic: use (t - warmup) as index into random_vals
            if trigger_rate < 1.0:
                rng_index = t - warmup  # Index into random sequence (0-based for positions >= warmup)
                if rng_index < random_vals.shape[0]:
                    rand_val = random_vals[rng_index]
                    if rand_val >= trigger_rate:
                        continue  # Skip this trigger
            
            # Emit intent
            created_bar[idx] = t - 1  # created_bar = t - 1
            price[idx] = price_val
            order_id[idx] = idx + 1  # Sequential order ID (1, 2, 3, ...)
            role[idx] = 1  # ROLE_ENTRY
            kind[idx] = 0  # KIND_STOP
            side[idx] = 1  # SIDE_BUY
            qty[idx] = order_qty
            
            idx += 1

else:
    # Fallback pure-python (used only if numba unavailable)
    def _deterministic_random(t: int, seed: int) -> float:  # type: ignore
        """Fallback pure-python implementation."""
        import random
        rng = random.Random(seed + t)
        return rng.random()

    def _count_valid_intents(  # type: ignore
        donch_prev: np.ndarray,
        warmup: int,
        trigger_rate: float,
        random_vals: np.ndarray,
    ) -> int:
        """Fallback pure-python implementation."""
        n = donch_prev.shape[0]
        count = 0
        
        for t in range(1, n):
            if t < warmup:
                continue
            
            price_val = donch_prev[t]
            if not (np.isfinite(price_val) and price_val > 0.0):
                continue
            
            if trigger_rate < 1.0:
                rng_index = t - warmup
                if rng_index < random_vals.shape[0]:
                    rand_val = random_vals[rng_index]
                    if rand_val >= trigger_rate:
                        continue
            
            count += 1
        
        return count

    def _build_sparse_intents(  # type: ignore
        donch_prev: np.ndarray,
        warmup: int,
        trigger_rate: float,
        random_vals: np.ndarray,
        order_qty: int,
        n_entry: int,
        created_bar: np.ndarray,
        price: np.ndarray,
        order_id: np.ndarray,
        role: np.ndarray,
        kind: np.ndarray,
        side: np.ndarray,
        qty: np.ndarray,
    ) -> None:
        """Fallback pure-python implementation."""
        n = donch_prev.shape[0]
        idx = 0
        
        for t in range(1, n):
            if t < warmup:
                continue
            
            price_val = donch_prev[t]
            if not (np.isfinite(price_val) and price_val > 0.0):
                continue
            
            if trigger_rate < 1.0:
                rng_index = t - warmup
                if rng_index < random_vals.shape[0]:
                    rand_val = random_vals[rng_index]
                    if rand_val >= trigger_rate:
                        continue
            
            created_bar[idx] = t - 1
            price[idx] = price_val
            order_id[idx] = idx + 1
            role[idx] = 1
            kind[idx] = 0
            side[idx] = 1
            qty[idx] = order_qty
            
            idx += 1


def build_entry_intents_numba(
    donch_prev: np.ndarray,
    channel_len: int,
    order_qty: int,
    trigger_rate: float = 1.0,
    seed: int = 42,
) -> dict:
    """
    Build entry intents using Numba-accelerated single-pass sparse builder.
    
    Args:
        donch_prev: float64 array (n_bars,) - shifted donchian high
        channel_len: Warmup period (same as indicator warmup)
        order_qty: Order quantity
        trigger_rate: Trigger rate (0.0 to 1.0, default 1.0)
        seed: Random seed for deterministic trigger rate selection (default 42)
    
    Returns:
        dict with:
            - created_bar: int32 array (n_entry,)
            - price: float64 array (n_entry,)
            - order_id: int32 array (n_entry,)
            - role: uint8 array (n_entry,)
            - kind: uint8 array (n_entry,)
            - side: uint8 array (n_entry,)
            - qty: int32 array (n_entry,)
            - n_entry: int
            - obs: dict with valid_mask_sum
    """
    from FishBroWFS_V2.config.dtypes import (
        INDEX_DTYPE,
        INTENT_ENUM_DTYPE,
        INTENT_PRICE_DTYPE,
    )
    
    n = int(donch_prev.shape[0])
    warmup = channel_len
    
    # Pre-compute random values (matching apply_trigger_rate_mask logic)
    # Generate random values for positions >= warmup
    random_vals = np.empty(0, dtype=np.float64)
    if trigger_rate < 1.0 and warmup < n:
        rng = np.random.default_rng(seed)
        random_vals = rng.random(n - warmup).astype(np.float64)
    
    # Pass 1: Count valid intents
    n_entry = _count_valid_intents(
        donch_prev=donch_prev,
        warmup=warmup,
        trigger_rate=trigger_rate,
        random_vals=random_vals,
    )
    
    # Diagnostic observations
    obs = {
        "n_bars": n,
        "warmup": warmup,
        "valid_mask_sum": n_entry,  # In numba builder, valid_mask_sum == n_entry
    }
    
    if n_entry == 0:
        return {
            "created_bar": np.empty(0, dtype=INDEX_DTYPE),
            "price": np.empty(0, dtype=INTENT_PRICE_DTYPE),
            "order_id": np.empty(0, dtype=INDEX_DTYPE),
            "role": np.empty(0, dtype=INTENT_ENUM_DTYPE),
            "kind": np.empty(0, dtype=INTENT_ENUM_DTYPE),
            "side": np.empty(0, dtype=INTENT_ENUM_DTYPE),
            "qty": np.empty(0, dtype=INDEX_DTYPE),
            "n_entry": 0,
            "obs": obs,
        }
    
    # Pass 2: Allocate and fill arrays
    created_bar = np.empty(n_entry, dtype=INDEX_DTYPE)
    price = np.empty(n_entry, dtype=INTENT_PRICE_DTYPE)
    order_id = np.empty(n_entry, dtype=INDEX_DTYPE)
    role = np.empty(n_entry, dtype=INTENT_ENUM_DTYPE)
    kind = np.empty(n_entry, dtype=INTENT_ENUM_DTYPE)
    side = np.empty(n_entry, dtype=INTENT_ENUM_DTYPE)
    qty = np.empty(n_entry, dtype=INDEX_DTYPE)
    
    _build_sparse_intents(
        donch_prev=donch_prev,
        warmup=warmup,
        trigger_rate=trigger_rate,
        random_vals=random_vals,
        order_qty=order_qty,
        n_entry=n_entry,
        created_bar=created_bar,
        price=price,
        order_id=order_id,
        role=role,
        kind=kind,
        side=side,
        qty=qty,
    )
    
    return {
        "created_bar": created_bar,
        "price": price,
        "order_id": order_id,
        "role": role,
        "kind": kind,
        "side": side,
        "qty": qty,
        "n_entry": n_entry,
        "obs": obs,
    }


